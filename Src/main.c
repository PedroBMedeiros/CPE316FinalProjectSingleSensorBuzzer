#include <stdio.h>

#include "main.h"
#include "usart.h"
#include "gpio.h"
#include "timer.h"

#define DELAY 50000
#define ZEROAF 0x000F
#define SETAF7 0X0007
#define BAUDRATE 278
#define RESETTRANSMISSION 0
#define ESCASCII 0x1B
#define CLOSEBRACKETASCII 0X5B
#define REDFONT "31m"
#define BLUEFONT "34m"
#define WHITEFONT "37m"
#define GREENFONT "32m"

volatile uint32_t risingEchoCapture;
volatile uint32_t fallingEchoCapture;
volatile uint32_t EchoPulseWidth;
volatile uint8_t bothEdgesFlag = 0;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);


void delay(volatile uint32_t count) {
    while (count--) {
        __NOP();  // No operation, just wait
    }
}

//void TIM2_IRQHandler(void) {
//	//USART2_Print("Measuring...");
//	// Wait for rising edge
//	if (TIM2->SR & TIM_SR_CC1IF) {
//		risingEchoCapture = TIM2->CCR1; // Capture timer value at rising edge
//		TIM2->SR &= ~TIM_SR_CC1IF; // Clear the flag
//	}
//	// Wait for falling edge
//	else if (TIM2->SR & TIM_SR_CC2IF) {
//		fallingEchoCapture = TIM2->CCR2; // Capture timer value at falling edge
//		TIM2->SR &= ~TIM_SR_CC2IF; // Clear the flag
//		bothEdgesFlag = 1;
//	}
//}


uint32_t Measure_Echo_Time(void) {
	uint32_t rising_edge = 0;
	uint32_t falling_edge = 0;
	uint32_t pulse_width;
	//USART2_Print("Measuring...");
	// Wait for rising edge
	while (!(TIM2->SR & TIM_SR_CC1IF));
	rising_edge = TIM2->CCR1; // Capture timer value at rising edge
	TIM2->SR &= ~TIM_SR_CC1IF; // Clear the flag

	// Wait for falling edge
	while (!(TIM2->SR & TIM_SR_CC2IF));
	falling_edge = TIM2->CCR2; // Capture timer value at falling edge
	TIM2->SR &= ~TIM_SR_CC2IF; // Clear the flag
	// Calculate pulse width in timer ticks

	if (falling_edge >= rising_edge) {
		pulse_width = falling_edge - rising_edge;
	} else {
		pulse_width = (TIM2->ARR - rising_edge) + falling_edge + 1;
	}
	return pulse_width; // Return the pulse width in ticks
}

//void TIM2_InCap_Init(void) { // generated by chat gpt copying online code
//    // Enable the TIM2 clock
//    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
//
//    // Set the prescaler to 71 (Prescaler value = PSC register + 1)
//    TIM2->PSC = 32 - 1;
//
//    // Set the ARR (auto-reload register) to 0xFFFF-1
//    TIM2->ARR = 0xFFFF - 1;
//
//    // Set Counter Mode to Up
//    TIM2->CR1 &= ~TIM_CR1_DIR;
//
//    // Set Clock Division to 1 (No Division)
//    TIM2->CR1 &= ~TIM_CR1_CKD;
//
//    // Disable Auto-Reload Preload (ARR is directly loaded)
//    TIM2->CR1 &= ~TIM_CR1_ARPE;
//
//    // Configure Input Capture for Channel 1
//    // Input capture polarity: Rising Edge
//    TIM2->CCER &= ~TIM_CCER_CC1P; // Clear falling edge bit (rising edge)
//    TIM2->CCER &= ~TIM_CCER_CC1NP; // No complementary polarity
//
//    // Input capture selection: Direct input (TI1)
//    TIM2->CCMR1 &= ~TIM_CCMR1_CC1S_Msk; // Clear CC1S bits
//    TIM2->CCMR1 |= TIM_CCMR1_CC1S_0;    // Set CC1S = 01 (Direct TI1)
//
//    // Input capture prescaler: No division
//    TIM2->CCMR1 &= ~TIM_CCMR1_IC1PSC_Msk;
//
//    // Input capture filter: No filter (0)
//    TIM2->CCMR1 &= ~TIM_CCMR1_IC1F_Msk;
//
//    // Master Mode Configuration
//    TIM2->CR2 &= ~TIM_CR2_MMS_Msk;     // Reset Master Mode Selection (No TRGO)
//    TIM2->SMCR &= ~TIM_SMCR_MSM;       // Disable Master-Slave Mode
//
//    // Enable Input Capture on Channel 1
//    TIM2->CCER |= TIM_CCER_CC1E;
//
//    // Enable the timer counter
//    TIM2->CR1 |= TIM_CR1_CEN;
//
//    // Enable Update Generation to load settings
//    TIM2->EGR |= TIM_EGR_UG;
//}
//
//void GPIO_Init_TIM1_CH1_RegisterLevel(void) { // chat gpt for initializing PB4 as echo for timer 3
//    // Step 1: Enable GPIOB Clock
//    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN;
//
//    // Step 2: Set PB4 to Alternate Function Mode
//    GPIOB->MODER &= ~GPIO_MODER_MODE4_Msk;  // Clear MODER bits for PB4
//    GPIOB->MODER |= GPIO_MODER_MODE4_1;    // Set MODER to Alternate Function (10)
//
//    // Step 3: Configure Alternate Function for PB4 (AF1 for TIM1_CH1)
//    GPIOB->AFR[0] &= ~GPIO_AFRL_AFSEL4_Msk; // Clear AFR bits for PB4
//    GPIOB->AFR[0] |= (2 << GPIO_AFRL_AFSEL4_Pos); // Set AFR to AF2 (TIM1_CH1)
//
//    // Step 4: Configure Pull-up/Pull-down as No Pull
//    GPIOB->PUPDR &= ~GPIO_PUPDR_PUPD4_Msk; // Clear PUPD bits for PB4
//    GPIOB->PUPDR |= GPIO_PUPDR_PUPD4_0;    // Optional: Set pull-up if needed
//
//    // Step 5: Set Output Speed to Low (Optional)
//    GPIOB->OSPEEDR &= ~GPIO_OSPEEDR_OSPEED4_Msk; // Clear speed bits for PB4
//    GPIOB->OSPEEDR |= GPIO_OSPEEDR_OSPEED4_0;    // Set to Low Speed (01)
//}

//void TIM2_InputCapture_Init(void) {
//    // Enable TIM2 clock
//    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
//
//    // Configure TIM2 for no prescaler, edge detection, and input capture
//    TIM2->PSC = 0;                              // No prescaler, f(TIM) = 32 MHz
//    TIM2->ARR = 0xFFFFFFFF;                     // Auto-reload for maximum count
//
//    // Configure TIM2_CH1 for input capture on rising edge
//    TIM2->CCMR1 &= ~TIM_CCMR1_CC1S;             // Clear CC1S bits
//    TIM2->CCMR1 |= TIM_CCMR1_CC1S_0;            // CC1 channel is mapped to input
//    TIM2->CCER &= ~TIM_CCER_CC1P;               // Capture on rising edge
//    TIM2->CCER &= ~TIM_CCER_CC1NP;              // No negative polarity
//    TIM2->CCER |= TIM_CCER_CC1E;                // Enable capture on channel 1
//
//    // Enable TIM2 interrupt
//    TIM2->DIER |= TIM_DIER_CC1IE;               // Enable CC1 interrupt
//    NVIC_EnableIRQ(TIM2_IRQn);                  // Enable TIM2 interrupt in NVIC
//    NVIC_SetPriority(TIM2_IRQn, 2);             // Set interrupt priority
//
//    // Start the timer
//    TIM2->CR1 |= TIM_CR1_CEN;                   // Enable the counter
//}

void GPIO_PA0_Init(void) {
    // Enable GPIOC clock
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // Configure PA0 as AF2 (TIM2_CH1)
    GPIOA->MODER &= ~GPIO_MODER_MODE0;          // Clear mode
    GPIOA->MODER |= GPIO_MODER_MODE0_1;         // Set to alternate function mode
    GPIOA->AFR[0] |= (1 << GPIO_AFRL_AFSEL0_Pos); // AF2 for TIM2
    GPIOA->PUPDR &= ~GPIO_PUPDR_PUPD0;          // No pull-up/pull-down
}

// TIM2 interrupt handler
void TIM2_IRQHandler(void) {
    if (TIM2->SR & TIM_SR_CC1IF) {              // Check if capture event occurred
        if ((TIM2->CCER & TIM_CCER_CC1P) == 0) { // Rising edge detected
            risingEchoCapture = TIM2->CCR1;     // Capture the count
            TIM2->CCER |= TIM_CCER_CC1P;        // Switch to falling edge detection
        } else {                                // Falling edge detected
            fallingEchoCapture = TIM2->CCR1;    // Capture the count
            EchoPulseWidth = fallingEchoCapture - risingEchoCapture; // Calculate pulse width
            bothEdgesFlag = 1;
            TIM2->CCER &= ~TIM_CCER_CC1P;       // Switch back to rising edge detection
        }
        TIM2->SR &= ~TIM_SR_CC1IF;              // Clear the interrupt flag
    }
}

void Config_PC0_Buzzer() {
	// Enable GPIOC clock
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOCEN;

	// Configure PC0 as general-purpose output
	GPIOC->MODER &= ~GPIO_MODER_MODE0;  // Clear mode bits for PC0
	GPIOC->MODER |= GPIO_MODER_MODE0_0; // Set mode to output (01)

	// Configure output type as push-pull (default)
	GPIOC->OTYPER &= ~GPIO_OTYPER_OT0; // Clear output type for PC0

	// Configure output speed as low speed (optional: change as needed)
	GPIOC->OSPEEDR &= ~GPIO_OSPEEDR_OSPEED0; // Clear speed bits for PC0
	GPIOC->OSPEEDR |= GPIO_OSPEEDR_OSPEED0_0; // Set speed to low (01)

	// Configure no pull-up, no pull-down (optional: adjust if needed)
	GPIOC->PUPDR &= ~GPIO_PUPDR_PUPD0; // Clear pull-up/pull-down for PC0
}

void tweet(uint32_t dist) {
	if (dist < 10) {
		// apitate
		GPIOC->ODR |= (GPIO_ODR_OD0);
	}
	else {
		GPIOC->ODR &= !(GPIO_ODR_OD0);
	}
}

void Timer_PWM_Init(void) {
    // Enable clock for TIM5 and GPIOA
    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM5EN;  // Enable TIM5 clock
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;   // Enable GPIOA clock

    // Configure PA1 as alternate function (AF2 for TIM5 CH2)
    GPIOA->MODER &= ~(GPIO_MODER_MODE1);   // Clear MODER for PA1
    GPIOA->MODER |= (GPIO_MODER_MODE1_1);  // Set PA1 to alternate function mode
    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL1);   // Clear AFR bits for PA1
    GPIOA->AFR[0] |= (2 << GPIO_AFRL_AFSEL1_Pos);  // Set AF2 for TIM5_CH2

    // Configure TIM5 for PWM mode
    TIM5->PSC = 32 - 1;         // Prescaler: 32 MHz / 32 = 1 MHz
    TIM5->ARR = 1000 - 1;       // Default frequency: 1 kHz (adjust dynamically)
    TIM5->CCR2 = 500;           // 50% duty cycle for channel 2
    TIM5->CCMR1 &= ~TIM_CCMR1_OC2M;
    TIM5->CCMR1 |= (6 << TIM_CCMR1_OC2M_Pos);  // PWM mode 1 for channel 2
    //TIM5->CCMR1 |= TIM_CCMR1_OC2PE;  // Enable preload for CCR2
    TIM5->CCER |= TIM_CCER_CC2E;     // Enable output on CH2
    //TIM5->CR1 |= TIM_CR1_ARPE;       // Enable auto-reload preload
    TIM5->EGR |= TIM_EGR_UG;         // Force update
    TIM5->CR1 |= TIM_CR1_CEN;        // Start timer
}

void Update_PWM(uint32_t distance) {
    if (distance > 150) {
        // Turn off PWM by disabling the output
    	TIM5->CCER &= ~TIM_CCER_CC2E;  // Disable output on CH1
        //delay(10000);
    } else {
    	//TIM5->CCER &= ~TIM_CCER_CC2E;  // Disable output on CH1
    	Timer_PWM_Init();
    	uint32_t frequency;
    	if (distance < 5) {
    		frequency = 40;
    	} else if (distance < 25) {
    		frequency = 20;
    	} else if (distance < 50) {
    		frequency = 10;
    	} else if (distance < 75) {
    		frequency = 6;
    	} else if (distance < 100) {
    		frequency = 4;
    	} else {
    		frequency = 2;
    	}
        // Update ARR for the new frequency
        TIM5->ARR = (1000000 / frequency) - 1;  // Adjust ARR for desired frequency
        TIM5->CCR2 = TIM5->ARR / 2;             // Maintain 50% duty cycle

        // Re-enable PWM output
        TIM5->CCER |= TIM_CCER_CC2E;  // Enable output on CH1
    }
}

int main(void)
{
  HAL_Init();
  SystemClock_Config();

  // initialize gpios
  RCC->AHB2ENR |= RCC_AHB2ENR_GPIOCEN;

  GPIO_PA0_Init(); // echo pin (PA0)
  GPIO_PC1_Init(); // trig init (PC1)
  //Config_PC0_Buzzer();
  Timer_PWM_Init();
  //GPIO_Init_TIM1_CH1_RegisterLevel(); // echo init (PB4)

  USART2_init(); // init uart
  Timer_Delay_Init(); // init tim3; initializing 10us timer
  //TIM2_InputCapture_Init(); // init TIM2; echo timer
  Timer_Input_Capture_Init();
  __enable_irq();
  //TIM2_InCap_Init();

  //TIM2->CCER |= TIM_CCER_CC1E;  // Enable Capture on Channel 1
  //TIM2->DIER |= TIM_DIER_CC1IE;  // Enable Capture/Compare interrupt for Channel 1
  //TIM2->CR1 |= TIM_CR1_CEN;  // Start the timer

  //Timer_Input_Capture_Init();

  char DistanceBuffer[10];
  //char EchoBuffer[10];
  //char risingEdgeBuffer[10];

  USART_ESC_Print("J");
  USART_ESC_Print("0;0H");

  while(1) {
//	  for (int i = 0; i < sizeof(DistanceBuffer); i++) {
//		  DistanceBuffer[i] = '\0';
//	  }
	  USART_ESC_Print("0;0H");
	  /* -------------- trig pin high for 10us ---------- */
	  /* we will set trig high, count to 320 on timer, set trig low */

	  GPIOC->ODR |= (GPIO_ODR_OD1); // set Trig high
	  Start_Delay_Timer();
	  Wait_Timer();
	  GPIOC->ODR &= ~(GPIO_ODR_OD1); // toggle Trig
	  /* -------------------------------------------------- */
	  //USART2_Print("Checkpoint2");
	  //delay(1152000);
	  while (bothEdgesFlag == 0);
	  //uint32_t pulse_ticks = Measure_Echo_Time(); // measure time gap for 'echo'
	  uint32_t distance = (EchoPulseWidth*5359)/10000000;
	  uint32_t roundingAgent =  (EchoPulseWidth*5359)%10000000;
	  if (roundingAgent > 5000000) {
		  distance += 1;
	  }

	  sprintf(DistanceBuffer, "%lu", distance);
	  //sprintf(EchoBuffer, "%lu", EchoPulseWidth*5359);
	  USART_ESC_Print("J");
	  USART2_Print("Distance: ");
	  USART2_Print(DistanceBuffer);
	  //tweet(distance);
	  Update_PWM(distance);
	  bothEdgesFlag = 0;
	  delay(1920000); // 60ms required delay for refresh based on 32Mhz clock
  }

//  while (1)
//  {
//	  for (int i = 0; i < sizeof(DistanceBuffer); i++) {
//		  DistanceBuffer[i] = '\0';
//	  }
//	  USART_ESC_Print("0;0H");
//	  /* -------------- trig pin high for 10us ---------- */
//	  /* we will set trig high, count to 320 on timer, set trig low */
//	  GPIOC->ODR |= (GPIO_ODR_OD1); // set Trig high
//	  Start_Delay_Timer();
//	  Wait_Timer();
//	  GPIOC->ODR &= ~(GPIO_ODR_OD1); // toggle Trig
//	  /* -------------------------------------------------- */
//
//	  uint32_t pulse_ticks = Measure_Echo_Time(); // measure time gap for 'echo'
//	  uint32_t distance = (pulse_ticks*5359)/10000000;
//	  sprintf(DistanceBuffer, "%lu", distance);
//	  USART_ESC_Print("J");
//	  USART2_Print("Distance: ");
//	  USART2_Print(DistanceBuffer);
//	  USART2_Print(" cm");
//	  delay(1920000);
//	  // update visual for distance
//	  // play sound on speaker depending on distance
//	  // wait for a set amount of time before refreshing
//  }

}

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 16;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
}

void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
